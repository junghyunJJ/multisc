
R version 2.15.1 (2012-06-22) -- "Roasted Marshmallows"
Copyright (C) 2012 The R Foundation for Statistical Computing
ISBN 3-900051-07-0
Platform: x86_64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> #Copyright (c) 2016 ZarLab
> 
> #     This program is free software: you can redistribute it and/or modify
> #     it under the terms of the GNU Affero General Public License as published by
> #     the Free Software Foundation, either version 3 of the License, or
> #     (at your option) any later version.
> 
> #     This program is distributed in the hope that it will be useful,
> #     but WITHOUT ANY WARRANTY; without even the implied warranty of
> #     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> #     GNU General Public License for more details.
> 
> #     You should have received a copy of the GNU General Public License
> #     along with this program.  If not, see <http://www.gnu.org/licenses/>.
> 
> rm(list=ls())
> library(gtools);
> library(mvtnorm);
> library(vegan);
Loading required package: permute

Attaching package: ‘permute’

The following object(s) are masked from ‘package:gtools’:

    permute

Loading required package: lattice
This is vegan 2.2-1
> ############### define functions ###############
> getp <- function(Y, x, p) {
+     res = adonis(Y ~ x, perm=p)
+     return(res$aov.tab$"Pr(>F)"[1])
+ }
> getF <- function(Y, x, p) {
+     res = adonis(Y ~ x, perm=p)
+     return(res$aov.tab$F.Model[1])
+ }
> gamma <- function(Y, x, max_itr=4) {
+     for (i in 2:max_itr) {
+         p = 10^i
+         limit = 5/p
+         pval = getp(Y, x, p)
+         if (pval > limit) {
+             break
+         }
+     }
+     return(pval)
+ }
> 
> chol_solve <- function(K) {
+     a = eigen(K)$vectors
+     b = eigen(K)$values
+     b[b<1e-13] = 1e-13
+     b = 1/sqrt(b)
+     return(a%*%diag(b)%*%t(a))
+ }
> 
> rotate <- function(Y, sigma) {
+     U <- chol_solve(sigma)
+     tU <-t(U)
+     UY = tU%*%Y
+     return(UY)
+ }
> 
> run_gamma <- function(Y, X) {
+     Ng = dim(X)[2]
+     pval = 1:Ng
+     fval = 1:Ng
+     newY = Y-min(Y)
+     for (i in 1:Ng) {
+         pval[i] = gamma(newY, X[,i])
+         fval[i] = getF(newY,X[,i],1)
+         cat(i,". f=",fval[i]," p=",pval[i],"\n")
+     }
+     return(list(pval, fval))
+ }
> ################## get input ###################
> args=(commandArgs(TRUE))
> if(length(args)!=5){
+         print("Usage: R CMD BATCH --args -Xpath= -Kpath= -Ypath= -VCpath= -outputPath= GAMMA.R GAMMA.log")
+         stop ()
+ }
> for (i in 1:5){
+         paramName =  strsplit(args[i],"=")[[1]][1]
+         param =strsplit(args[i],"=")[[1]][2]
+         if(paramName=="-Xpath")
+                 Xpath = param
+         else if(paramName=="-outputPath")
+                 outputPath = param
+         else if(paramName=="-Kpath")
+         	Kpath = param
+         else if(paramName=="-Ypath")
+                 Ypath = param
+ 	else if(paramName=="-VCpath")
+                 VCpath = param
+ 	else {
+                 cat("Error: Wrong parameter name ",paramName)
+                 stop()
+         }
+ }
> print(Xpath)
[1] "./testData/X_rightdim.txt"
> print(Kpath)
[1] "./testData/K.txt"
> print(Ypath)
[1] "./testData/Y_rightdim.txt"
> print(VCpath)
[1] "./testData/VC.txt"
> print(outputPath)
[1] "./testData/"
> ################## GAMMA  ##################
> X = as.matrix(read.table(Xpath)) # read input
> K = as.matrix(read.table(Kpath))
> Y = as.matrix(read.table(Ypath))
> VC = as.matrix(read.table(VCpath))
> snpNum <- dim(X)[2]
> indiNum <- dim(X)[1]
> geneNum <- dim(Y)[2]
> Vg = median(VC[,1])		# Variance components
> Ve = median(VC[,2])
> I = diag(indiNum)
> sigma = Vg*K + Ve*I
> UY = rotate(Y,sigma)		# Rotate genotypes and phenotypes
> UX = rotate(X,sigma)
> ps2 = run_gamma(UY, UX)		# GAMOVA
1 . f= 0.939014  p= 0.7623762 
2 . f= 0.878204  p= 0.9306931 
3 . f= 0.8703245  p= 0.970297 
4 . f= 0.9067913  p= 0.8910891 
5 . f= 0.8886251  p= 0.950495 
6 . f= 0.8790101  p= 0.950495 
7 . f= 0.8393743  p= 1 
8 . f= 0.904423  p= 0.9009901 
9 . f= 1.002133  p= 0.4158416 
10 . f= 0.9230237  p= 0.8811881 
11 . f= 1.019822  p= 0.4554455 
12 . f= 1.615465  p= 9.999e-05 
13 . f= 0.8692386  p= 0.980198 
14 . f= 0.9495185  p= 0.6633663 
15 . f= 0.9002049  p= 0.9405941 
16 . f= 0.9291494  p= 0.7920792 
17 . f= 1.048851  p= 0.2673267 
18 . f= 0.9498796  p= 0.7722772 
19 . f= 0.9616218  p= 0.5742574 
20 . f= 0.9641337  p= 0.7326733 
21 . f= 0.9190089  p= 0.8613861 
22 . f= 0.946343  p= 0.6831683 
23 . f= 0.9417464  p= 0.7722772 
24 . f= 3.755623  p= 9.999e-05 
25 . f= 0.9422679  p= 0.7128713 
26 . f= 0.9621285  p= 0.6237624 
27 . f= 0.9554835  p= 0.7425743 
28 . f= 0.9595852  p= 0.6831683 
29 . f= 0.8250451  p= 1 
30 . f= 3.29044  p= 9.999e-05 
31 . f= 0.9423872  p= 0.8217822 
32 . f= 0.9468201  p= 0.7128713 
33 . f= 1.098883  p= 0.1089109 
34 . f= 1.026886  p= 0.2772277 
35 . f= 0.973795  p= 0.6732673 
36 . f= 0.8852749  p= 0.970297 
37 . f= 1.048267  p= 0.2574257 
38 . f= 0.9449991  p= 0.7029703 
39 . f= 0.7971074  p= 1 
40 . f= 0.9111883  p= 0.9405941 
41 . f= 0.9578704  p= 0.6336634 
42 . f= 0.9446726  p= 0.7920792 
43 . f= 0.8858284  p= 0.9207921 
44 . f= 0.938648  p= 0.7623762 
45 . f= 0.9738685  p= 0.5643564 
46 . f= 0.9844  p= 0.5841584 
47 . f= 0.8832296  p= 0.990099 
48 . f= 0.8643789  p= 0.990099 
49 . f= 0.9247419  p= 0.8712871 
50 . f= 0.8687902  p= 0.950495 
51 . f= 0.9000291  p= 0.9108911 
52 . f= 0.9881225  p= 0.5445545 
53 . f= 0.9099994  p= 0.8712871 
54 . f= 0.8789352  p= 0.970297 
55 . f= 1.053245  p= 0.1980198 
56 . f= 2.598124  p= 9.999e-05 
57 . f= 0.9742275  p= 0.6435644 
58 . f= 0.9501572  p= 0.7524752 
59 . f= 0.903838  p= 0.9108911 
60 . f= 0.904423  p= 0.9306931 
61 . f= 0.9746125  p= 0.6138614 
62 . f= 0.9740794  p= 0.6237624 
63 . f= 0.9436639  p= 0.7821782 
64 . f= 0.9531015  p= 0.7821782 
65 . f= 1.018919  p= 0.3762376 
66 . f= 0.8933186  p= 0.9306931 
67 . f= 0.9470017  p= 0.7524752 
68 . f= 0.8415463  p= 0.990099 
69 . f= 0.8703245  p= 0.950495 
70 . f= 0.8502533  p= 0.990099 
71 . f= 0.758211  p= 1 
72 . f= 0.8812324  p= 0.9405941 
73 . f= 0.9221401  p= 0.8019802 
74 . f= 1.171704  p= 0.07920792 
75 . f= 0.945308  p= 0.7920792 
76 . f= 0.9435236  p= 0.7524752 
77 . f= 0.8674551  p= 0.970297 
78 . f= 1.030388  p= 0.2871287 
79 . f= 0.8886251  p= 0.9306931 
80 . f= 0.8975552  p= 0.9108911 
81 . f= 0.951932  p= 0.6930693 
82 . f= 0.8513488  p= 0.980198 
83 . f= 0.9173211  p= 0.9405941 
84 . f= 0.8276284  p= 1 
85 . f= 0.7836577  p= 1 
86 . f= 0.9714615  p= 0.6336634 
87 . f= 1.059888  p= 0.2277228 
88 . f= 0.8606571  p= 1 
89 . f= 0.9095398  p= 0.8613861 
90 . f= 0.8853428  p= 0.980198 
91 . f= 0.8980512  p= 0.9108911 
92 . f= 0.8144886  p= 0.990099 
93 . f= 0.9146934  p= 0.8910891 
94 . f= 0.9235869  p= 0.8316832 
95 . f= 0.8940382  p= 0.960396 
96 . f= 1.486216  p= 0.00019998 
97 . f= 0.9381146  p= 0.8217822 
98 . f= 0.834719  p= 1 
99 . f= 1.039309  p= 0.2970297 
100 . f= 0.9172214  p= 0.8613861 
> write.table(ps2[1], paste(outputPath, "/P.txt", sep=""), row.names=FALSE, col.names=FALSE, quote=FALSE)
> write.table(ps2[2], paste(outputPath, "/F.txt", sep=""), row.names=FALSE, col.names=FALSE, quote=FALSE)
> 
> proc.time()
   user  system elapsed 
 27.448   0.331  28.198 
